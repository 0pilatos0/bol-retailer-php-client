<?php


namespace Picqer\BolRetailerV4\OpenApi;

class ClientGenerator
{
    protected $specs;

    protected static $paramTypeMapping = [
        'array' => 'array',
        'string' => 'string',
        'boolean' => 'bool',
        'integer' => 'int',
        'float' => 'float',
        'number' => 'float'
    ];

    public function __construct()
    {
        $this->specs = json_decode(file_get_contents(__DIR__ . '/apispec.json'), true);
    }

    public function generateClient()
    {
        $code = [];
        $code[] = '<?php';
        $code[] = '';
        $code[] = sprintf('namespace %s;', $this->getClientNamespace());
        $code[] = '';
        $code[] = '// This class is auto generated by OpenApi\ClientGenerator';
        $code[] = 'class Client extends BaseClient';
        $code[] = '{';
//        $this->generateMethod('/retailer/orders', 'get', $code);
//        $this->generateMethod('/retailer/offers', 'post', $code);
//        $this->generateMethod('/retailer/orders/{order-id}', 'get', $code);
//        $this->generateMethod('/retailer/shipping-labels/{shipping-label-id}', 'get', $code);
        foreach ($this->specs['paths'] as $path => $methodsDef) {
            foreach ($methodsDef as $method => $methodDef) {
                $this->generateMethod($path, $method, $code);
            }
        }
        $code[] = '}';
        $code[] = '';

        //echo implode("\n", $code);

        file_put_contents(__DIR__ . '/../Client.php', implode("\n", $code));
    }

    protected function generateMethod(string $path, string $httpMethod, array &$code): void
    {
        $methodDefinition = $this->specs['paths'][$path][$httpMethod];

        echo "{$methodDefinition['operationId']}...";

        $returnType = $this->getReturnType($methodDefinition['responses']);

        if ($returnType === null) {
            echo "unsupported returnType\n";
            return;
        }

        $methodName = $this->kebabCaseToCamelCase($methodDefinition['operationId']);
        $arguments = $this->extractArguments($methodDefinition['parameters'] ?? []);

        $phpDocReturnType = $returnType;
        if (isset($methodDefinition['responses']['404'])) {
            $phpDocReturnType = $returnType . '|null';
            $returnType = '?' . $returnType;
        }

        $argumentsList = $this->getArgumentsList($arguments);

        $code[] = '';
        $code[] = '    /**';
        // TODO break at 120 chars
        $code[] = '     * ' . $methodDefinition['description'];
        $this->addParamsPhpDoc($arguments, $code);
        $code[] = sprintf('     * @return %s', $phpDocReturnType);
        $code[] = '     * @throws Exception\ConnectException when an error occurred in the HTTP connection.';
        $code[] = '     * @throws Exception\ResponseException when an unexpected response was received.';
        $code[] = '     * @throws Exception\UnauthorizedException when request was unauthorized.';
        $code[] = '     * @throws Exception\Exception when something unexpected went wrong.';
        $code[] = '     */';
        $code[] = sprintf('    public function %s(%s): %s', $methodName, $argumentsList, $returnType);
        $code[] = '    {';
        $code[] = sprintf('        $url = "%s";', $this->getUrl($path, $arguments));

        $options = '[]';
        $code[] = '        $options = [';
        $this->addQueryParams($arguments, $code);
        $this->addBodyParam($arguments, $code);
        $code[] = sprintf('            \'produces\' => \'%s\',', $methodDefinition['produces'][0]);
        $code[] = '        ];';
        $options = '$options';

        $this->addResponseTypes($methodDefinition['responses'], $code);

        $code[] = '';
        $code[] = sprintf(
            '        return $this->request(\'%s\', $url, %s, $responseTypes);',
            strtoupper($httpMethod),
            $options
        );
        $code[] = '    }';

        echo "ok\n";
        //print_r($methodDefinition);
    }

    protected function getType(string $ref): string
    {
        //strip #/definitions/
        $type = substr($ref, strrpos($ref, '/') + 1);

        // There are some weird types like 'delivery windows for inbound shipments.', uppercase and concat
        $type = str_replace(['.', ','], '', $type);
        $words = explode(' ', $type);
        $words = array_map(function ($word) {
            return ucfirst($word);
        }, $words);
        $type = implode('', $words);

        // Classname 'Return' is not allowed in php <= 7
        if ($type == 'Return') {
            $type = 'ReturnObject';
        }

        return $type;
    }

    protected function getClientNamespace()
    {
        return substr(__NAMESPACE__, 0, strrpos(__NAMESPACE__, '\\'));
    }

    protected function addParamsPhpDoc(array $arguments, array &$code): void
    {
        // TODO break at 120 chars
        foreach ($arguments as $argument) {
            if (empty($argument['description'])) {
                $code[] = sprintf(
                    '     * @param %s %s',
                    $argument['type'],
                    $argument['name']
                );
            } else {
                $code[] = sprintf(
                    '     * @param %s %s %s',
                    $argument['type'],
                    $argument['name'],
                    $argument['description']
                );
            }
        }
    }

    protected function kebabCaseToCamelCase(string $name): string
    {
        // Fix for bug in specs where name contains spaces (e.g. 'get packing list')
        $name = str_replace(' ', '-', $name);

        $nameElems = explode('-', $name);
        for ($i=1; $i<count($nameElems); $i++) {
            $nameElems[$i] = ucfirst($nameElems[$i]);
        }
        return implode('', $nameElems);
    }

    protected function getUrl(string $path, array $arguments): string
    {
        $url = substr($path, strlen('/retailer/'));

        foreach ($arguments as $argument) {
            if ($argument['in'] != 'path') {
                continue;
            }

            $url = str_replace(
                '{' . $argument['paramName'] . '}',
                '${' . $argument['name'] . '}',
                $url
            );
        }

        return $url;
    }

    protected function extractArguments(array $parameters): array
    {
        $argsWithoutDefault = [];
        $argsWithDefault = [];

        foreach ($parameters as $parameter) {
            $argument = [
                'default' => null,
                'description' => null,
                'in' => $parameter['in'],
                'paramName' => null
            ];

            if ($parameter['in'] == 'body') {
                $type = $this->getType($parameter['schema']['$ref']);
                $argument['type'] = 'Model\\' . $type;
                $argument['name'] = lcfirst($type);
            } else {
                $argument['type'] = static::$paramTypeMapping[$parameter['type']];
                $argument['name'] = $this->kebabCaseToCamelCase($parameter['name']);
                $argument['paramName'] = $parameter['name'];
                if (isset($parameter['default'])) {
                    if ($parameter['type'] == 'string') {
                        $defaultValue = str_replace(['\''], ['\\\''], $parameter['default']);
                        $argument['default'] = sprintf('\'%s\'', $defaultValue);
                    } else {
                        $argument['default'] = $parameter['default'];
                    }
                    $argument['description'] = $parameter['description'];
                }
            }

            if ($argument['default'] !== null) {
                $argsWithDefault[] = $argument;
            } else {
                $argsWithoutDefault[] = $argument;
            }
        }

        return array_merge($argsWithoutDefault, $argsWithDefault);
    }

    protected function getArgumentsList(array $arguments): string
    {
        $argumentsList = [];

        foreach ($arguments as $argument) {
            if ($argument['default'] !== null) {
                $argumentsList[] = sprintf('%s $%s = %s', $argument['type'], $argument['name'], $argument['default']);
            } else {
                $argumentsList[] = sprintf('%s $%s', $argument['type'], $argument['name']);
            }
        }

        return implode(', ', $argumentsList);
    }

    protected function addQueryParams(array $arguments, array &$code): void
    {
        $amount = array_reduce($arguments, function ($amount, $argument) {
            return $argument['in'] == 'query' ? $amount+1 : $amount;
        });

        if ($amount == 0) {
            return;
        }

        $code[] = '            \'query\' => [';

        foreach ($arguments as $argument) {
            if ($argument['in'] != 'query') {
                continue;
            }
            $code[] = sprintf('                \'%s\' => $%s,', $argument['paramName'], $argument['name']);
        }
        $code[] = '            ],';
    }

    protected function addBodyParam(array $arguments, array &$code): void
    {
        foreach ($arguments as $argument) {
            if ($argument['in'] != 'body') {
                continue;
            }

            $code[] = sprintf('            \'body\' => $%s,', $argument['name']);

            return;
        }
    }

    protected function addResponseTypes(array $responses, array &$code): void
    {
        $code[] = '        $responseTypes = [';
        foreach ($responses as $httpStatus => $response) {
            $type = null;
            if (in_array($httpStatus, ['200', '202'])) {
                if (! isset($response['schema'])) {
                    // There are 2 methods that return a csv, but have no response type defined
                    $type = '\'string\'';
                } elseif (isset($response['schema']['$ref'])) {
                    $type = '\'' . $this->getType($response['schema']['$ref']) . '\'';
                } else {
                    $type = '\'string\'';
                }
            } elseif ($httpStatus == '404') {
                $type = '\'null\'';
            }
            if ($type !== null) {
                $code[] = sprintf('            \'%s\' => %s,', $httpStatus, $type);
            }
        }
        $code[] = '        ];';
    }

    protected function getReturnType(array $responses): ?string
    {
        $response = $responses['200'] ?? $responses['202'] ?? null;
        if ($response === null) {
            throw new \Exception('Could not fit responseType');
        }

        if (! isset($response['schema'])) {
            // There are 2 methods that return a csv, but have no response type defined
            return 'string';
        } elseif (isset($response['schema']['$ref'])) {
            return 'Model\\' . $this->getType($response['schema']['$ref']);
        } else {
            // currently only array is support

            if ($response['schema']['type'] != 'array' || $response['schema']['items']['format'] != 'byte') {
                throw new \Exception("Only Models and raw bytes are supported as response type");
            }
            return 'string';
        }
    }
}
